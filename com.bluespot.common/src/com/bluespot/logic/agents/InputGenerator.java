package com.bluespot.logic.agents;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import com.bluespot.logic.functions.SafeFunction;

/**
 * A producer of values of a specified type.
 * <p>
 * Generation is done in separate rounds. Each round applies every provided
 * input value to every provided function. A round ends when no more
 * permutations are available. However, a new round is made available which
 * contains the accumulated input values and functions from all previous rounds.
 * <p>
 * This generator will never return equal values, regardless of the state of
 * current round.
 * 
 * @author Aaron Faanes
 * 
 * @param <I>
 *            the type of values that are generated by this object
 */
public class InputGenerator<I> implements Iterator<I> {

	private I next;

	private Round<I> round;

	/**
	 * Create a new {@link InputGenerator} object that uses the specified
	 * functions and values in the first round.
	 * 
	 * @param pool
	 *            a collection of objects that will be used to generate input
	 *            values
	 * @param generatedType
	 *            the required type of generated input values
	 */
	public InputGenerator(Class<? extends I> generatedType, Collection<? extends Object> pool) {
		this.round = new Round<I>(generatedType, pool);
	}

	@Override
	public I next() {
		if (!this.round.hasBegun()) {
			next = this.round.search();
		}
		if (next == null) {
			throw new IllegalStateException("Next element is not available");
		}
		I thisValue = next;
		while ((next = this.round.search()) == null) {
			this.round = this.round.nextRound();
		}
		return thisValue;
	}

	@Override
	public boolean hasNext() {
		if (!this.round.hasBegun()) {
			next = this.round.search();
		}
		return next != null;
	}

	/**
	 * Add an object to this generator's pool.
	 * 
	 * @param value
	 *            the value to add
	 * @throw {@link IllegalStateException} if this generator cannot accept
	 *        arguments at this time
	 */
	public void add(Object value) {
		this.round.add(value);
	}

	private static class Round<I> {

		private final Class<? extends I> generatedType;

		private Set<Object> pool;

		private SafeFunction<?> currentOperator;
		private Iterator<Object> operatorIterator;
		private Iterator<Object> poolIterator;

		private HashSet<I> blacklist;
		private Round<I> nextRound;

		public Round(Class<? extends I> generatedType, Collection<? extends Object> pool) {
			this.generatedType = generatedType;
			this.pool = new HashSet<Object>(pool);
			this.pool.add(null);
			this.blacklist = new HashSet<I>();
		}

		private Round(Round<I> round) {
			this(round.getGeneratedType(), round.getPool());
			this.blacklist = round.blacklist;
		}

		private Class<? extends I> getGeneratedType() {
			return this.generatedType;
		}

		/**
		 * Return a view of this generator's pool. The pool contains all values
		 * used during the generation process.
		 * 
		 * @return an unmodifiable view of this generator's pool
		 */
		private Set<? extends Object> getPool() {
			return Collections.unmodifiableSet(this.pool);
		}

		/**
		 * Add a value to this round's pool. If the value is already contained
		 * in the round's pool, this invocation has no effect.
		 * 
		 * @param value
		 *            the value to add to the pool
		 */
		public void add(Object value) {
			this.pool.add(value);
		}

		/**
		 * Begin generation. This invocation has no effect if generation has
		 * already started.
		 */
		private void begin() {
			if (this.hasBegun()) {
				return;
			}
			// We're a new round, so freeze our state and begin.
			this.pool = Collections.unmodifiableSet(this.pool);
			this.nextRound = new Round<I>(this);

			this.operatorIterator = this.pool.iterator();
			this.nextOperator();
			this.poolIterator = this.pool.iterator();
		}

		/**
		 * Load the next available operator from the pool.
		 */
		private void nextOperator() {
			this.currentOperator = null;
			while (this.currentOperator == null && this.operatorIterator.hasNext()) {
				Object operator = this.operatorIterator.next();
				if (operator == null) {
					continue;
				}
				if (SafeFunction.class.isInstance(operator)) {
					this.currentOperator = (SafeFunction<?>) operator;
				}
			}
		}

		// We run into the problem of equality here. Consider these two functions:
		// y = x + 2
		// y = x + 2 + 1 - 1
		// These are logically equivalent, so at least one of them should be
		// retained. However, they're not equal according to Object#equals, so
		// we'd lose this result.
		//
		// To resolve this, we either need some simplifying process, or we need to
		// ensure that functions are always produced in their simplest form.
		//
		// Also consider the possibility that the result might be composed of two
		// separate functions. In this case, there may not be a single function that
		// fits both results. In this scenario, we should attempt to create a
		// piece-wise function from the discarded candidates.
		private I search() {
			this.begin();
			while (this.isAlive()) {
				while (this.poolIterator.hasNext()) {
					Object input = this.poolIterator.next();
					Object generated = this.currentOperator.apply(input);
					if (generated == null) {
						continue;
					}
					this.nextRound.add(generated);
					if (this.generatedType.isInstance(generated)) {
						I candidate = this.generatedType.cast(generated);
						if (!this.blacklist.contains(candidate)) {
							this.blacklist.add(candidate);
							return candidate;
						}
					}
				}
				this.poolIterator = this.pool.iterator();
				this.nextOperator();
			}
			// We've exhausted every permutation, so just die.
			return null;
		}

		public boolean hasBegun() {
			return this.nextRound != null;
		}

		public boolean isAlive() {
			return this.currentOperator != null;
		}

		public Round<I> nextRound() {
			if (!this.hasBegun()) {
				throw new IllegalStateException("Current round has not yet begun");
			}
			if (this.isAlive()) {
				throw new IllegalStateException("Current round has not finished");
			}
			return this.nextRound;
		}
	}

	@Override
	public void remove() {
		throw new UnsupportedOperationException("Removal is not supported");
	}

}