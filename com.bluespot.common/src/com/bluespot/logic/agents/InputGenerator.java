package com.bluespot.logic.agents;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import com.bluespot.logic.functions.Function;
import com.bluespot.logic.functions.SafeFunction;

/**
 * A producer of values of a specified type.
 * <p>
 * Generation is done in separate rounds. Each round applies every provided
 * input value to every provided function. A round ends when no more
 * permutations are available. However, a new round is made available which
 * contains the accumulated input values and functions from all previous rounds.
 * <p>
 * This generator will never return equal values, regardless of the state of
 * current round.
 * 
 * @author Aaron Faanes
 * 
 * @param <I>
 *            the type of values that are generated by this object
 */
public class InputGenerator<I> implements Iterator<I> {

	private I next;

	private Round<I> round;

	public InputGenerator(Collection<? extends Function<Object, ?>> functions, Class<I> guardType) {
		this(functions, guardType, Collections.<Object> emptySet());
	}

	/**
	 * Create a new {@link InputGenerator} object that uses the specified
	 * functions and values in the first round.
	 * 
	 * @param functions
	 *            a collection of {@link Function} objects that will be used to
	 *            generate input values
	 * @param inputType
	 *            the required type of generated input values
	 * @param values
	 *            a collection of values that will be passed to each
	 *            {@link Function} in {@code functions}. {@code null} will
	 *            always be passed along with other values.
	 */
	public InputGenerator(Collection<? extends Function<Object, ?>> functions, Class<I> inputType, Collection<? extends Object> values) {
		if (functions == null) {
			throw new NullPointerException("functions must not be null");
		}
		this.round = new Round<I>(inputType, functions, values);
		next = this.round.search();
	}

	@Override
	public I next() {
		I thisValue = next;
		while ((next = this.round.search()) == null) {
			this.round = this.round.nextRound();
		}
		return thisValue;
	}

	@Override
	public boolean hasNext() {
		return next != null;
	}

	private static class Round<I> {

		private final Class<I> generatedType;
		private Set<Object> blacklist;

		private Function<Object, ?> currentFunc;
		private Set<Function<Object, ?>> functions;
		private Iterator<Function<Object, ?>> functionIterator;

		private Set<Object> values;
		private Iterator<Object> valueIterator;

		private Round<I> nextRound;

		private Round(Class<I> inputType, Collection<? extends Function<Object, ?>> functions, Collection<? extends Object> values) {
			this.generatedType = inputType;
			this.functions = new HashSet<Function<Object, ?>>(functions);
			if (this.functions.isEmpty()) {
				throw new IllegalArgumentException("functions must contain at least one function");
			}
			this.values = new HashSet<Object>(values);
			this.values.add(null);
			this.blacklist = new HashSet<Object>();
		}

		private Round(Round<I> parentRound, Set<Object> blacklist) {
			this(parentRound.getGeneratedType(), parentRound.getFunctions(), parentRound.getValues());
			this.blacklist = blacklist;
		}

		private Collection<? extends Object> getValues() {
			return Collections.unmodifiableSet(this.values);
		}

		private Collection<? extends Function<Object, ?>> getFunctions() {
			return Collections.unmodifiableSet(this.functions);
		}

		private Class<I> getGeneratedType() {
			return this.generatedType;
		}

		public void addFunction(Function<Object, ?> function) {
			this.functions.add(function);
		}

		public void addValue(Object value) {
			this.values.add(value);
		}

		private void begin() {
			if (this.nextRound != null) {
				return;
			}
			// We're a new round, so freeze our state and begin.
			this.functions = Collections.unmodifiableSet(this.functions);
			this.values = Collections.unmodifiableSet(this.values);
			this.nextRound = new Round<I>(this, this.blacklist);

			this.functionIterator = this.functions.iterator();
			this.valueIterator = this.values.iterator();
			this.currentFunc = this.functionIterator.next();
		}

		public I search() {
			this.begin();
			while (this.isAlive()) {
				while (this.valueIterator.hasNext()) {
					I generated = this.analyzeResult(this.currentFunc.apply(this.valueIterator.next()));
					if (generated != null) {
						return generated;
					}
				}
				this.valueIterator = this.values.iterator();
				if (this.functionIterator.hasNext()) {
					this.currentFunc = this.functionIterator.next();
				} else {
					this.currentFunc = null;
				}
			}
			// At this point, we've exhausted every permutation, so just return null.
			return null;
		}

		public boolean hasBegun() {
			return this.nextRound != null;
		}

		public boolean isAlive() {
			return this.currentFunc != null;
		}

		/**
		 * Check if the specified value is a a "useful" result. Useful values
		 * are defined as:
		 * <ul>
		 * <li>A {@link SafeFunction} object, that will be used as another
		 * generator in the next generation round
		 * <li>A non-null value. These values will be used as input values in
		 * the next generation round
		 * <li>A value of type {@link #generatedType}, which will be returned as
		 * a generated value. These values will also be used as inputs in the
		 * next generation round
		 * </ul>
		 * 
		 * @param generated
		 *            the analyzed value
		 * 
		 * @return {@code generated} cast as {@link #generatedType} if such a
		 *         cast would succeed
		 */
		private I analyzeResult(Object generated) {
			if (generated == null) {
				return null;
			}
			if (this.blacklist.contains(generated)) {
				return null;
			}
			this.blacklist.add(generated);
			this.nextRound.addValue(generated);
			if (SafeFunction.class.isInstance(generated)) {
				this.nextRound.addFunction((SafeFunction<?>) generated);
			}
			if (this.generatedType.isInstance(generated)) {
				I candidate = this.generatedType.cast(generated);
				return candidate;
			}
			return null;
		}

		public Round<I> nextRound() {
			if (!this.hasBegun()) {
				throw new IllegalStateException("Current round has not yet begun");
			}
			if (this.isAlive()) {
				throw new IllegalStateException("Current round has not finished");
			}
			return this.nextRound;
		}
	}

	@Override
	public void remove() {
		throw new UnsupportedOperationException("Removal is not supported");
	}

}